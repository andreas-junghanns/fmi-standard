= Network Communication and FMI 3.0
:sectnums:
:sectnumlevels: 5
:toc: left
:toc-title: Contents
:toclevels: 5
:xrefstyle: short
:docinfo: shared
:docinfodir: docs
:stylesheet: docs/fmi-spec.css
:stem: latexmath
:source-highlighter: highlightjs
:nofooter:
:favicon: images/favicon.ico
:revdate: unreleased
:revnumber: 3.0
:icons: font

This layered standard on top of FMI 3.0, defines how to describe and simulate network signals as input and output variables of an FMU.

{empty} +
{empty}

Copyright (C) 2008-2011 MODELISAR Consortium and 2012-2020 The Modelica Association Project FMI.

This document is licensed under the Attribution-ShareAlike 4.0 International license.
The code is released under the 2-Clause BSD License.
The licenses text can be found in the https://raw.githubusercontent.com/modelica/fmi-standard/master/LICENSE.txt[LICENSE.txt] file that accompanies this distribution.

{empty}

== Introduction

=== Intend of this Document

Automotive CAN, LIN, FlexRay, CAN FD and CAN XL are network technologies that have been applied successfully over many years by all automotive OEMs world wide.
Virtualizing electronic control units (ECUs) and then simulating multiple such vECUs requires connecting them using a virtual version of these network technologies.
Reusing standard network topology description formats, such as DBC, LDF, Fibex and ARXML, is required for efficiency and testing reasons alike.
Files in these formats exist in validated form as part of the engineering process, tooling exists and these standards evolve to support new use cases.

This document describes how to use standard description formats for automotive topologies on top of the FMI 3.0 standard.
vECUs following this standard can then easily be connected in importing tools because the network description files declare which signals have what properties and belong to what messages in which of the potentially multiple networks connected to each vECUs.
The importer does not need to know about the special network semantics of certain signals of an FMU; it simply forwards signal values according to the FMI standard.

Signal and message properties will be extracted from the network description files and it allows all exporters and importers to have the same understanding and interpretation of the FMU signals.
Such signal properties are, for example: signal scaling, message timing and trigger conditions, packaging of signals in messages, unit definitions.
This document does not address potential open points of these description formats, it is assumed that such ambiguities will be handled elsewhere (e.g. message timing in the DBC format).
This document does not address IP protection or copyright issues.
These are technical and legal issues that need attention from standardization bodies of the referenced description formats, tool vendors and end users.

=== Basic Aspects of this Layered Standard

This standard supports two abstraction layers for network stacks:

Signal abstraction layer (also "high cut"):: physical signals as exchanged between the application software (ASW) and the basic software (BSW), in AUTOSAR this would be the Virtual Function Bus, and

Frame abstraction layer (also "low cut"):: binary signals which represent an entire frame/message as exchanged through the micro-controller abstraction layer (MCAL) between BSW and the hardware driver.

Standardized network description files shipped with each FMU describe properties of signals and frames, such as signal units, frame composition and trigger conditions.
These network description files are placed into the `/extra/org.modelica.fmi.networks4FMI` folder.

Both abstraction layers are nearly equivalent and can be translated into one another using the network description files.
Depending on the export tool, one of the abstraction layers is more "natural" to the FMU, while the other might have to be emulated with additional internal effort.
Importers on the other hand rarely require both abstraction layers for system level compositions, because the engineering task defines the level of abstraction for the network communication.
FMUs may choose to only support one abstraction layer providing only the corresponding variables.
However, for versatility, having FMU capable of communicating on both abstraction layers is convenient for users.

If an FMU is capable of providing both abstraction layers (showing by the appropriate input and output variables), the FMU may allow the importer to indicate which abstraction layer it uses with the following fmi3Boolean, tunable, structural parameters:
 * `BusName::SignalLayer_InputsUsed`:: indicates if the importer supplies the signal abstraction layer input variables values to the FMU
 * `BusName::SignalLayer_OutputsUsed`:: indicates if the importer reads the output variables of the signal abstraction layer
 * `BusName::FrameLayer_InputsUsed`:: indicates if the importer supplies the frame abstraction layer input variables values to the FMU
 * `BusName::FrameLayer_OutputsUsed`:: indicates if the importer reads the output variables of the frame abstraction layer

Since network communication is not continuous but time discrete, FMI 3.0 clock variables are used to indicate when signals or frames are sent.
All signal and frame variables are clocked variables.

FMI 3.0 terminal definition in the `modelDescription.xml` for each level of grouping: networks, frames and PDUs allow system composition tools without knowledge of the network description format to semantically group signals.
To map between the FMU variables and the network variables, FMU variable names are structured, e.g. `BusName::FrameName::PDUName::SignalName`.

If an FMU specifies nodes that are both senders and receivers of a frame, the receiver role will be removed from the FMU interface to allow the signals to have a unique role as output.
_[The FMI standard requires a variable to be either input or output.]_

== Details

=== Network Description Files

FMI 3.0 introduces an `/extra` folder in its `zip` structure.
The network description files will be placed under the reverse domain name controlled by the MAP FMI: `/extra/org.modelica.fmi.networks4FMI`.
DBC, LDF, Fibex and ARXML files are allowed.
The root name of the description files shall be used as network identifier in the bus terminal type and are case sensitive, e.g. `POWERTRAIN.dbc`.

Multiple files can be specified, each one defining one network architecture used by the FMU.
This standard does not support composing one network architecture from multiple description files, even if using internal include mechanisms, it rather enforces the rule: one network - one file.

It is recommended to use ARXML over DBC files for CAN whenever possible, because the DBC standard lacks some key message properties that were added only later using non-standard extensions with different dialects in use.

=== Variables

This section explains the different variable types used to carry network traffic through FMI input and output variables.

==== Signal Variables

A signal variable carries the physical value of a network signal normally packaged inside a PDU or frame.
The unit definition of the variable must match the one defined in the network description file.

Each network signal must be listed as <<TerminalMemberVariable>> of its corresponding <<PDUterminal>>.

In case multiplexed signals are present in a message: all signals are present, but only the active signal according to the multiplex switch signal contains a valid value, all inactive values must be ignored _[those values could even be outside their specified min-max range without fault]_.

==== Frame Variable [[FrameVariable]]

A frame variable is of type `fmi3Binary` and represents the entire frame, from and including "Start of Frame" until and including "End of Frame".
Such a frame variable is formed like this `BusName::FrameName`, e.g. `Powertrain::tcuSensors` (see <<Example>>).

Each frame variable must be listed as <<TerminalMemberVariable>> of its corresponding <<BUSterminal>>.

If one output frame has such a binary representation of the entire frame, all output frames must have such a binary representation of the frame.
Any of the input frames may have such a binary representation of the entire frame as input variable.

==== Frame Clock Variable [[ClockVariable]]

In order to use FMU input and output variables as transport layer for networks, aperiodic, triggered input and output clocks are used.
Such a clock is activated by the sender to indicate the transmission of the corresponding frame.
Each frame `BusName::FrameName` has its own dedicated clock variable named `BusName::FrameName_CLOCK`, e.g. `POWERTRAIN::ecuState_CLOCK`.
All clocked variables triggered by this clock belonging to the same frame are then valid and can be read by the importer.

=== Terminal Definitions

==== Bus Terminal [[BUSterminal,Bus Terminal]]

Each network connected to the FMU must be described by a bus terminal named `BusName` in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>` that wraps all <<FrameTerminals,frame terminals>>.
The network name must match the root name of its description file
_[e.g. `Powertrain`, if the file is `/extra/org.modelica.fmi.layered_BUS/Powertrain.dbc`]_.

Attribute definitions::
 * `terminalKind` must be set to `bus`.
 * `matchingRule` must be set to `bus`.
 * `name` is the network name, e.g. `POWERTRAIN`, see example and constraints above.

Element definitions::
 * There must be no `<TerminalMemberVariable>` element.
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one `<Terminal>` element per network frame described in the description file.

Annotation element::
 * In the annotation elements, there will be an `<Annotation>` element defining which node or nodes of the network description file are wrapped inside the FMU.
If the combination of nodes specified for this FMU turns a message and its signals into both input and output because sending and receiving nodes are specified, only the sending (output) role will be defined in the FMU interface.
Receiving messages must then be handled internal to the FMU.

// TODO: do we need to define what the graphical representation looks like? Or should we not allow it?

==== Frame Terminal [[FrameTerminals,Frame Terminal]]

Each frame listed in the description file must be an element of its corresponding network terminal (see `<Terminal>` element of bus terminal).

Attribute definitions::
 * `terminalKind` must be set to `frame`.
 * `matchingRule` must be set to `bus`.
 * `name` must match the frame name of the network description file in `/extra/org.modelica.fmi.layered_BUS`.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one `<Terminal>` element per PDU of this frame.
 * There must be one `<TerminalMemberVariable>` for the clock this frame is connected to.
   This variable is composed as <<ClockVariable,`BusName::FrameName_CLOCK`>>, e.g. `POWERTRAIN::tcuSensors_CLOCK`.
 * Furthermore, there can be an optional variable of type `fmi3Binary` that represents the entire frame, including `Start-of-Frame` and `End-of-Frame`.
   This variable is composed as <<FrameVariable,`BusName::FrameName_FRAME`>>, e.g. `POWERTRAIN::tcuSensors_FRAME`.

==== PDU Terminal [[PDUterminal,PDU Terminal]]

Each PDU listed in the description file must be an element of its corresponding frame terminal (see `<Terminal>` element of frame terminal).

Attribute definitions::
 * `terminalKind` must be set to `pdu`.
 * `matchingRule` must be set to `bus`.
 * `name` must match a PDU name of the network description file in `/extra/org.modelica.fmi.layered_BUS`.
   If the network type or network description format does not allow for PDUs (CAN and LIN), a single, synthetic PDU with the same name as the frame it belongs to must be created, e.g. `tcuSensors`.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be no `<Terminal>` element.
 * There must be one `<TerminalMemberVariable>` per signal of this PDU.

All `<TerminalMemberVariables>` must have the same type of either input or output, including the clock.

For network types not natively referencing a "PDU", like CAN, a synthetic PDU with the same name as its frame is inserted.

==== Terminal Member Variable [[TerminalMemberVariable,Terminal Member Variable]]

Attribute definitions::
 * `variableName` refers to the input or output variable name of the FMU and to enforce uniqueness is built as follows: `BusName::FrameName::PDUName::SignalName`, e.g. `POWERTRAIN::tcuSensors::tcuSensors::vCar`.
 * `memberName` is the `SignalName` as given in the network description file, e.g. `vCar`.
 * `variableKind` is `signal`.

=== Example [[Example,Example]]

The following excerpts from files are used throughout this document as examples.

.Example POWERTRAIN.dbc file
[#POWERTRAIN.dbc]
[source, C]
----
...
BO_ 256 tcuSensors: 4 TCU
 SG_ vCar :          0|16@1- (32,0)  [-500|500] "km/h" ECU
 SG_ oilTemp :      16|9@1-  (2,50)  [-50|150]  "s" ECU

BO_ 257 tcuState: 2 TCU
 SG_ state :         0|2@1+  (1,0)   [ 0|2] "-" ECU
 SG_ gear :          2|4@1-  (1,0)   [-2|6] "-" ECU
 SG_ targetGear :    6|4@1-  (1,0)   [-2|6] "-" ECU

BO_ 512 ecuState: 4 ECU
 SG_ accelPedal :    0|8@1+ (2,0)   [0|100]   "%" TCU
 SG_ k15 :           8|1@1+ (1,0)   [0|1]     "-" TCU
 SG_ oilTemp :       9|9@1- (2,50)  [-50|150] "°C" TCU
 SG_ radiatorTemp : 18|9@1- (2,50)  [-50|150] "°C" TCU
...
----

.Example modelDescription.xml for ECU node
[#modelDescription.xml]
[source, XML]
----
<ModelVariables>
  <Float64 name="POWERTRAIN::tcuSensors::tcuSensors::vCar"     valueReference="1001" causality="input" variability="discrete" start="0"/>
  <Float64 name="POWERTRAIN::tcuSensors::tcuSensors::oilTemp"  valueReference="1002" causality="input" variability="discrete" start="20"/>
  <Binary  name="POWERTRAIN::tcuSensors_FRAME"                 valueReference="1003" causality="input" variability="discrete" start="0"/>
  <Clock   name="POWERTRAIN::tcuSensors_CLOCK"                 valueReference="1004" causality="input" variability="clock" interval="triggered"/>

  <Float64 name="POWERTRAIN::tcuState::tcuState::state"        valueReference="1005" causality="input" variability="discrete" start="0"/>
  <Float64 name="POWERTRAIN::tcuState::tcuState::gear"         valueReference="1006" causality="input" variability="discrete" start="0"/>
  <Float64 name="POWERTRAIN::tcuState::tcuState::targetGear"   valueReference="1007" causality="input" variability="discrete" start="0"/>
  <Binary  name="POWERTRAIN::tcuState_FRAME"                   valueReference="1008" causality="input" variability="discrete" start="0"/>
  <Clock   name="POWERTRAIN::tcuState_CLOCK"                   valueReference="1009" causality="input" variability="clock" interval="triggered"/>

  <Float64 name="POWERTRAIN::ecuState::ecuState::accelPedal"   valueReference="1010" causality="output" variability="discrete" start="0"/>
  <Float64 name="POWERTRAIN::ecuState::ecuState::k15"          valueReference="1011" causality="output" variability="discrete" start="0"/>
  <Float64 name="POWERTRAIN::ecuState::ecuState::oilTemp"      valueReference="1012" causality="output" variability="discrete" start="0"/>
  <Float64 name="POWERTRAIN::ecuState::ecuState::radiatorTemp" valueReference="1012" causality="output" variability="discrete" start="0"/>
  <Binary  name="POWERTRAIN::ecuState_FRAME"                   valueReference="1013" causality="output" variability="discrete" start="0"/>
  <Clock   name="POWERTRAIN::ecuState_CLOCK"                   valueReference="1014" causality="output" variability="clock" interval="triggered"/>
</ModelVariables>
----

.Example terminalsAndIcons.xml file
[#terminalsAndIcon.xml]
[source, XML]
----
<?xml version="1.0" encoding="UTF-8"?>
<fmiTerminalsAndIcons fmiVersion="3.0-alpha6">
  <Terminals>
    <Terminal terminalKind="bus" name="POWERTRAIN" matchingRule="bus" description="Powertrain CAN bus defined with dbc file">
      <Annotation type="ECU" />
      <Terminal terminalKind="frame" name="tcuSensors" matchingRule="bus">
        <Terminal terminalKind="pdu" name="tcuSensors" matchingRule="bus">
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuSensors::tcuSensors::vCar" memberName="vCar" />
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuSensors::tcuSensors::oilTemp" memberName="oilTemp" />
        </Terminal>
        <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuSensors_FRAME" />
        <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuSensors_CLOCK" />
      </Terminal>
      <Terminal terminalKind="frame" name="tcuState" matchingRule="bus">
        <Terminal terminalKind="pdu" name="tcuState" matchingRule="bus">
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuState::tcuState::state" memberName="state" />
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuState::tcuState::gear" memberName="gear" />
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuState::tcuState::targetGear" memberName="targetGear" />
        </Terminal>
        <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuState_FRAME" />
        <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::tcuState_CLOCK" />
      </Terminal>
      <Terminal terminalKind="frame" name="ecuState" matchingRule="bus">
        <Terminal terminalKind="pdu" name="ecuState" matchingRule="bus">
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::ecuState::ecuState::accelPedal" memberName="accelPedal" />
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::ecuState::ecuState::k15" memberName="k15" />
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::ecuState::ecuState::oilTemp" memberName="oilTemp" />
          <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::ecuState::ecuState::radiatorTemp" memberName="radiatorTemp" />
        </Terminal>
        <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::ecuState_FRAME" />
        <TerminalMemberVariable variableKind="signal" variableName="POWERTRAIN::ecuState_CLOCK" />
      </Terminal>
    </Terminal>
   <GraphicalRepresentation>
...
   </GraphicalRepresentation>
  </Terminals>
</fmiTerminalsAndIcons>
----

=== Known Limitations of this Standard

This layered standard maps several network protocols onto co-simulation variables as transport layer simulating in many ways an ideal network.
Such an ideal network differs from physical networks in the following ways:

 * Network frame arbitration: frames are sent on the wire according to network-specific priority rules.
   Here all message are transmitted at the same time without delay.

 * Network congestion/bandwidth: too many network frames sent for the bandwidth of the network.
   Here the network has infinite capacity.

 * Protocol functions of higher levels: i.e. CAN request for retransmit is a specific protocol function.
   Here such specialties must be handled by the first layer inside the FMU.

 * Incoming buffer overflow: when an ECU receives more frames than its buffer can hold.
   Here the FMU will receive all frames, regardless of buffer size.

 * Network transmission errors: electrical errors which cause failed frame transmission.
   Here no such transmission errors can occur, unless explicitly added into the simulation.
