= FMI4Networking: Network Communication and FMI 3.0
:sectnums:
:sectnumlevels: 5
:toc: left
:toc-title: Contents
:toclevels: 5
:xrefstyle: short
:docinfo: shared
:docinfodir: docs
:stylesheet: docs/fmi-spec.css
:stem: latexmath
:source-highlighter: highlightjs
:nofooter:
:favicon: images/favicon.ico
:revdate: unreleased
:revnumber: 3.0
:icons: font

This layered standard on top of FMI 3.0, defines how to describe and simulate network signals as input and output variables of an FMU.

{empty} +
{empty}

Copyright (C) 2008-2011 MODELISAR Consortium and 2012-2020 The Modelica Association Project FMI.

This document is licensed under the Attribution-ShareAlike 4.0 International license.
The code is released under the 2-Clause BSD License.
The licenses text can be found in the https://raw.githubusercontent.com/modelica/fmi-standard/master/LICENSE.txt[LICENSE.txt] file that accompanies this distribution.

{empty}

== Introduction

=== Intend of this Document

Automotive CAN, LIN, FlexRay, CAN FD and CAN XL are network technologies that have been applied successfully over many years by all automotive OEMs world wide.
Virtualizing electronic control units (ECUs) and then simulating multiple such vECUs requires connecting them using a virtual version of these network technologies.
Reusing standard network topology description formats, such as DBC, LDF, Fibex and ARXML, is required for efficiency and testing reasons alike.
Files in these formats exist in validated form as part of the engineering process, tooling exists and these standards evolve to support new use cases.

This document describes how to use standard description formats for automotive topologies on top of the FMI 3.0 standard.
vECUs following this standard can then easily be connected in importing tools because the network description files declare which signals have what properties and belong to what messages in which of the potentially multiple networks connected to each vECUs.
The importer does not need to know about the special network semantics of certain signals of an FMU; it simply forwards signal values according to the FMI standard.

Signal and message properties will be extracted from the network description files and it allows all exporters and importers to have the same understanding and interpretation of the FMU signals.
Such signal properties are, for example: signal scaling, message timing and trigger conditions, packaging of signals in messages, unit definitions.
This document does not address potential open points of these description formats, it is assumed that such ambiguities will be handled elsewhere (e.g. message timing in the DBC format).
This document does not address IP protection or copyright issues.
These are technical and legal issues that need attention from standardization bodies of the referenced description formats, tool vendors and end users.

=== Basic Aspects of this Layered Standard

This standard supports two abstraction layers for network stacks:

Signal abstraction layer (also "high cut"):: physical signals as exchanged between the application software (ASW) and the basic software (BSW), in AUTOSAR this would be the Virtual Function Bus, and

Frame abstraction layer (also "low cut"):: binary signals which represent an entire frame/message as exchanged through the micro-controller abstraction layer (MCAL) between BSW and the hardware driver.

Standardized network description files shipped with each FMU describe properties of signals and frames, such as signal units, frame composition and trigger conditions.
These network description files are placed into the `/extra/org.modelica.fmi.networks4FMI` folder.

Both abstraction layers are nearly equivalent and can be translated into one another using the network description files.
Depending on the export tool, one or the other abstraction layer is more "natural" to the FMU, while the other might have to be emulated with additional internal effort.
Importers on the other hand rarely require both abstraction layers for system level compositions, because the engineering task defines the level of abstraction for the network communication.
FMUs may choose to only support one abstraction layer providing only the corresponding variables.

If an FMU is capable of providing both abstraction layers (showing by the appropriate input and output variables), the FMU may allow the importer to indicate which abstraction layer it uses with the following fmi3Boolean, tunable, structural parameters:
 * `BusName::SignalLayer_InputsUsed`:: indicates if the importer supplies the signal abstraction layer input variables values to the FMU
 * `BusName::SignalLayer_OutputsUsed`:: indicates if the importer reads the output variables of the signal abstraction layer
 * `BusName::FrameLayer_InputsUsed`:: indicates if the importer supplies the frame abstraction layer input variables values to the FMU
 * `BusName::FrameLayer_OutputsUsed`:: indicates if the importer reads the output variables of the frame abstraction layer

Since network communication is not continuous but time discrete, FMI 3.0 clock variables are used to indicate when signals or frames are sent, which in turn are all clocked variables.

System composition tools without knowledge of the network description format can semantically group signals using the FMI 3.0 terminal definition in the `modelDescription.xml` for each level of grouping: networks, frames and PDUs containing signals, also reflected in the variable names, e.g. `BusName::FrameName::PDUName::SignalName`.

If an FMU specifies nodes that are both senders and receivers of a frame, the receiver role will be removed from the FMU interface to allow the signals to have a unique role as output.
_[The FMI standard requires a variable to be either input or output.]_

== Details

=== Network Description Files

FMI 3.0 introduces an `/extra` folder in its `zip` structure.
The network description files will be placed under the reverse domain name controlled by the MAP FMI: `/extra/org.modelica.fmi.layered_BUS`.
DBC, LDF, Fibex and ARXML files are allowed.
The root name of the description files shall be used as network identifier in the bus terminal type and are case sensitive.

Multiple files can be specified, each one defining one network architecture used by the FMU.
This standard does not support composing one network architecture from multiple description files.

It is recommended to use ARXML over DBC files for CAN whenever possible, because the DBC standard lacks some key properties that have later been added using non-standard extensions with many dialects in use.

=== Terminal Definitions

==== Bus Terminal

Each network connected to the FMU must be described by a bus terminal named `BusName` in `icons/terminalsAndIcons.xml` as a `<Terminal>` element of `<fmiTerminalsAndIcons><Terminals>` that wraps all frame terminals.
The network name must match the root name of its description file
_[e.g. `Powertrain`, if the file is `/extra/org.modelica.fmi.layered_BUS/Powertrain.dbc`]_.

// TODO: EXAMPLE here

Attribute definitions::
 * `terminalKind` must be set to `bus`.
 * `matchingRule` must be set to `bus`.
 * `name` is the network name, e.g. `Powertrain`, see example and constraints above.

Element definitions::
 * There must be no `<TerminalMemberVariable>` element.
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be one `<Terminal>` element per network frame described in the description file.

Annotation element::
 * In the annotation elements, there will be an `<Annotation>` element defining which node or nodes of the network description file are wrapped inside the FMU.
If the combination of nodes specified for this FMU turns a message and its signals into both input and output because sending and receiving nodes are specified, only the sending (output) role will be defined in the FMU interface.
Receiving messages must then be handled internal to the FMU.

// TODO: how would that work in an annotation?

// TODO: do we need to define what the graphical representation looks like? Or should we not allow it?

==== Frame Terminal

Each frame listed in the description file must be an element of its corresponding network terminal (see `<Terminal>` element of bus terminal).

Attribute definitions::
 * `terminalKind` must be set to `frame`.
 * `matchingRule` must be set to `bus`.
 * `name` must match the frame name of the network description file in `/extra/org.modelica.fmi.layered_BUS`, prefixed with the network name and `::`.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be no `<Terminal>` element.
 * There must be one `<TerminalMemberVariable>` per PDU of this frame.
 * There must be one `<TerminalMemberVariable>` for the clock referenced by all signals of this frame with their `clockReference` attribute (included via all PDU terminals, see below).
   This variable is named <<ClockVariable,`BusName::FrameName_CLOCK`>>.
 * Optionally, there can be an additional `<TerminalMemberVariable>` element referencing a variable of type `fmi3Binary` that contains the binary representation of the frame payload (only).
   This variable is named <<PayloadVariable,`BusName::FrameName_PAYLOAD`>>.
 * Furthermore, there can be an optional variable of type `fmi3Binary` that represents the entire frame.
   This variable is named <<FrameVariable,`BusName::FrameName_FRAME`>>.

For network types not natively referencing a "frame", like CAN, usually a trivial concept mapping exists, e.g. a CAN "message" is equivalent to a "frame" in the more general sense.

==== PDU Terminal

Each PDU listed in the description file must be an element of its corresponding frame terminal (see `<Terminal>` element of frame terminal).

Attribute definitions::
 * `terminalKind` must be set to `pdu`.
 * `matchingRule` must be set to `bus`.
 * `name` must match the PDU name of the network description file in `/extra/org.modelica.fmi.layered_BUS`, prefixed with the network name and `::`.
   If the network type or network description format does not allow for PDUs (CAN and LIN), a single, synthetic PDU with the same name as the frame it belongs to must be created.

Element definitions::
 * There must be no `<TerminalStreamMemberVariable>` element.
 * There must be no `<Terminal>` element.
 * There must be one `<TerminalMemberVariable>` per signal of this PDU.

All `<TerminalMemberVariables>` must have the same type of either input or output, including the clock.

=== Variables

==== Signal Variables

Each network signal must be listed as `<TerminalMemberVariable>` of its corresponding PDU terminal.

Attribute definitions::
 * `variableName` refers to the input or output variable name of the FMU and to enforce uniqueness is built as follows: `BusName::FrameName::PDUName::SignalName`.
 * `memberName` is the `SignalName` as given in the network description file.
 * `variableKind` is `signal_physical` for all variables that represent physical (numeric) variables.
   For variables of type `fmi3Binary` the `variableKind` is set to `signal_binary`.

In case multiplexed signals are present in a message: all signals are present, but only the active signal according to the multiplex switch signal contains a valid value, all inactive values must be ignored _[those values could even be outside their specified min-max range without fault]_.

==== Frame Clock Variable [[ClockVariable]]

// TODO check after clocks are fixed

In order to use FMU input and output variables as transport layer for networks, aperiodic clock variables are used.
Such a clock is activated by the sender to indicate the transmission of the corresponding frame.
Each frame `BusName::FrameName` has its own dedicated clock variable named `BusName::FrameName_CLOCK`.
All clocked variables triggered by this clock belonging to the same frame are then valid and can be read by the recipients of this frame.
The value of the clocked variable must be a frame counter modulus 1024.

_[Using a frame counter allows recipients to detect dropped messages._
_These clocks must be aperiodic clocks to allow for non-ideal network communication patterns.]_

==== Frame Payload Variable [[PayloadVariable]]

There can be an optional `fmi3Binary` variable representing the payload of the frame.
For a frame `BusName::FrameName` the name of the payload variable is `BusName::FrameName_PAYLOAD`.

If one output frame has such a binary representation of the frame payload, all output frames must have such a binary representation of their payload.
Any of the input frames may have such a binary representation of the frame payload as input variable.

==== Frame Variable [[FrameVariable]]

There can be an optional `fmi3Binary` variable representing the entire frame, from and including "Start of Frame" until and including "End of Frame".
For network frame `BusName::FrameName`, the name of the network-frame variable is `BusName::FrameName_FRAME`.

If one output frame has such a binary representation of the entire frame, all output frames must have such a binary representation of the frame.
Any of the input frames may have such a binary representation of the entire frame as input variable.

=== Known Limitations of this Standard

This layered standard maps several network protocols onto co-simulation variables as transport layer simulating in many ways an ideal network.
Such an ideal network differs from physical networks in the following ways:

 * Network frame arbitration: frames are sent on the wire according to network-specific priority rules.
   Here all message are transmitted at the same time without delay.

 * Network congestion/bandwidth: too many network frames sent for the bandwidth of the network.
   Here the network has infinite capacity.

 * Protocol functions of higher levels: i.e. CAN request for retransmit is a specific protocol function.
   Here such specialties must be handled by the first layer inside the FMU and require <<FrameVariable,binary frame variables>>.

 * Incoming buffer overflow: when an ECU receives more frames than its buffer can hold.
   Here the FMU will receive all frames, regardless of buffer size.

 * network transmission errors: electrical errors which cause failed frame transmission.
   Here no such transmission errors can occur, unless explicitly added into the simulation.
